---
layout: doc
title: Integrate Your Python Flask Application With FusionAuth
description: Integrate your Python Flask application with FusionAuth
navcategory: getting-started
---

:page-liquid:

// TBD how much these are useful
:prequisites: python3 and pip3
:technology: Python Flask
:language: python

== Integrate Your {technology} Application With FusionAuth

In this article, you are going to learn how to integrate a {technology} application with FusionAuth.

Here's a typical application login flow before integrating FusionAuth into your {technology} application.
++++
{% plantuml source: _diagrams/docs/login-before.plantuml, alt: "Login before FusionAuth." %}
++++

And here's the same application login flow when FusionAuth is introduced.
++++
{% plantuml source: _diagrams/docs/login-after.plantuml, alt: "Login with FusionAuth." %}
++++

== Prerequisites

For this tutorial, you’ll need to have {prequisites} installed. You'll also need Docker, since that is how you'll install FusionAuth.

The commands below are for macOS, but are limited to `mkdir` and `cd`.

== Download and Install FusionAuth

First, make a project directory:

[source,shell]
----
mkdir integrate-fusionauth && cd integrate-fusionauth
----

Then, install FusionAuth:

[source,bash]
----
curl -o docker-compose.yml https://raw.githubusercontent.com/FusionAuth/fusionauth-containers/master/docker/fusionauth/docker-compose.yml
curl -o .env https://raw.githubusercontent.com/FusionAuth/fusionauth-containers/master/docker/fusionauth/.env
docker-compose up -d
----

== Create a User and an API Key

Next, http://localhost:9011[log into your FusionAuth instance].
You’ll need to set up a user and a password, as well as accept the terms and conditions. 

Then, you’re at the FusionAuth admin UI.
This lets you configure FusionAuth manually.
But for this tutorial, you're going to create an API key and then you’ll configure FusionAuth using our {language} client library.

Navigate to [breadcrumb]#Settings -> API Keys#. Click the [uielement]#+# button to add a new API Key.
Copy the value of the [field]#Key# field and then save the key.
It might be a value like `CY1EUq2oAQrCgE7azl3A2xwG-OEwGPqLryDRBCoz-13IqyFYMn1_Udjt`.

Doing so creates an API key that can be used for any FusionAuth API call.
Save that key value off as you’ll be using it later.

== Configure FusionAuth

Next, you need to set up FusionAuth.
This can be done in different ways, but we’re going to use the {language} client library.
The below instructions use maven from the command line, but you can use the client library with an IDE of your preference as well.

First, make a directory:

[source,shell]
----
mkdir setup-fusionauth && cd setup-fusionauth
----

If you want, you can http://localhost:9011[login to your instance] and
examine the new application configuration the script created for you after you are done.

Now, cut and paste the following file into `requirements.txt`.

[source,text,title="Your FusionAuth configuration requirements file"]
----
include::https://raw.githubusercontent.com/FusionAuth/fusionauth-example-client-libraries/main/python/requirements.txt[]
----

Then copy and paste the following code into the `setup.py` file.

[source,python]
----
from fusionauth.fusionauth_client import FusionAuthClient
import os
import sys

APPLICATION_ID = "e9fdb985-9173-4e01-9d73-ac2d60d1dc8e";

#  You must supply your API key 
api_key_name = 'fusionauth_api_key'
api_key = os.getenv(api_key_name)
if not api_key:
  sys.exit("please set api key in the '" + api_key_name + "' environment variable")

client = FusionAuthClient(api_key, 'http://localhost:9011')

# set the issuer up correctly    
client_response = client.retrieve_tenants()
if client_response.was_successful():
  tenant = client_response.success_response["tenants"][0]
else:
  sys.exit("couldn't find tenants " + str(client_response.error_response))

client_response = client.patch_tenant(tenant["id"], {"tenant": {"issuer":"http://localhost:9011"}})
if not client_response.was_successful():
  sys.exit("couldn't update tenant "+ str(client_response.error_response))

# generate RSA keypair for signing
rsa_key_id = "356a6624-b33c-471a-b707-48bbfcfbc593"

client_response = client.generate_key({"key": {"algorithm":"RS256", "name":"For PythonExampleApp", "length": 2048}}, rsa_key_id)
if not client_response.was_successful():
  sys.exit("couldn't create RSA key "+ str(client_response.error_response))

# create application
# too much to inline it

application = {}
application["name"] = "PythonExampleApp"

# configure oauth
application["oauthConfiguration"] = {}
application["oauthConfiguration"]["authorizedRedirectURLs"] = ["http://localhost:5000/callback/"] 
application["oauthConfiguration"]["requireRegistration"] = True
application["oauthConfiguration"]["enabledGrants"] = ["authorization_code", "refresh_token"]
application["oauthConfiguration"]["logoutURL"] = "http://localhost:5000/logout"
application["oauthConfiguration"]["clientSecret"] = "change-this-in-production-to-be-a-real-secret"

# some libraries don't support pkce, notably mozilla-django-oidc: https://github.com/mozilla/mozilla-django-oidc/issues/397
# since we are server side and have a solid client secret, we're okay turning pkce off
application["oauthConfiguration"]["proofKeyForCodeExchangePolicy"] = "NotRequiredWhenUsingClientAuthentication"

# assign key from above to sign our tokens. This needs to be asymmetric
application["jwtConfiguration"] = {}
application["jwtConfiguration"]["enabled"] = True
application["jwtConfiguration"]["accessTokenKeyId"] = rsa_key_id
application["jwtConfiguration"]["idTokenKeyId"] = rsa_key_id

client_response = client.create_application({"application": application}, APPLICATION_ID)
if not client_response.was_successful():
  sys.exit("couldn't create application "+ str(client_response.error_response))

# register user, there should be only one, so grab the first
client_response = client.search_users_by_query({"search": {"queryString":"*"}})
if not client_response.was_successful():
  sys.exit("couldn't find users "+ str(client_response.error_response))

user = client_response.success_response["users"][0]

# patch the user to make sure they have a full name, otherwise OIDC has issues
client_response = client.patch_user(user["id"], {"user": {"fullName": user["firstName"]+" "+user["lastName"]}})
if not client_response.was_successful():
  sys.exit("couldn't patch user "+ str(client_response.error_response))

# now register the user
client_response = client.register({"registration":{"applicationId":APPLICATION_ID}}, user["id"])
if not client_response.was_successful():
  sys.exit("couldn't register user "+ str(client_response.error_response))
----

Then, you can run the setup script. You'll use `venv` to keep your workspace clean. This will create FusionAuth
configuration for your {technology} application.

[source,shell]
----
python -m venv venv && \
source venv/bin/activate && \
pip install -r requirements.txt 
----

Now run the setup script:

[source,shell]
----
fusionauth_api_key=<your API key> python setup.py
----

This configures FusionAuth for your {technology} application.

== Create Your {technology} Application

Now you are going to create a {technology} application. While this section builds a simple {technology} application, you can use the same configuration to integrate your complex {technology} application with FusionAuth.

First, make a directory:

[source,shell]
----
mkdir ../setup-flask && cd ../setup-flask
----

Now, create a new `requirements.txt` file to include {technology}.
Add the `flask`, 'python-dotenv', and `authlib` plugins so that your requirements file looks like this:

[source,text,title="Your application requirements file"]
----
flask>=2.2.3
python-dotenv>=1.0.0
authlib>=1.2.0
----

Then, re-run `pip install` to install these new packages

[source,shell]
----
pip install -r requirements.txt
----

Next, create a file called `.env` and insert the following into it.

[source,ini]
----
CLIENT_ID=e9fdb985-9173-4e01-9d73-ac2d60d1dc8e
CLIENT_SECRET=change-this-in-production-to-be-a-real-secret
ISSUER=http://localhost:9011
APP_SECRET_KEY=my_super_secret_key_that_needs_to_be_changed
----

You can now start writing the code for your Flask webserver. Create a new file called `server.py` and add the following import statements into it:

[source,python]
----
import json
from os import environ as env
from urllib.parse import quote_plus, urlencode

from authlib.integrations.flask_client import OAuth
from dotenv import find_dotenv, load_dotenv
from flask import Flask, redirect, render_template, session, url_for
----

The following code uses `json` to surface the user's OpenID profile, `os.environ`, `dotenv.find_dotenv`, and `dotenv.load_dontenv` to load environment variables, `urllib.parse.quote_plus` and `urllib.parse.urlencode` to build the logout URL, `authlib.integrations.flask_client.OAuth` to handle OIDC verification, and various `flask` modules to facilitate the app's functionality.

Next, locate the `.env` file and retrieve the `APP_SECRET_KEY` environment variable:

[source,python]
----
ENV_FILE = find_dotenv()
if ENV_FILE:
    load_dotenv(ENV_FILE)
    
app = Flask(__name__)
app.secret_key = env.get("APP_SECRET_KEY")
----

Then, register your application with the FusionAuth server.

[source,python]
----
oauth = OAuth(app)

oauth.register(
    "FusionAuth",
    client_id=env.get("CLIENT_ID"),
    client_secret=env.get("CLIENT_SECRET"),
    client_kwargs={
        "scope": "openid profile email",
        'code_challenge_method': 'S256' # This enables PKCE
    },
    server_metadata_url=f'{env.get("ISSUER")}/.well-known/openid-configuration'
)
----

Now, you can start adding service routes. 
First, add the `login` route, which uses the new FusionAuth registration to authorize a redirect to the callback URL.

[source,python]
----
@app.route("/login")
def login():
    return oauth.FusionAuth.authorize_redirect(
        redirect_uri=url_for("callback", _external=True)
    )
----

Next, add the `callback` route, which surfaces the FusionAuth login screen and uses the information supplied to it to generate an access token.

[source,python]
----
@app.route("/callback", methods=["GET", "POST"])
def callback():
    token = oauth.FusionAuth.authorize_access_token()
    session["user"] = token
    return redirect("/")
----

Then, add a `logout` route, which simply clears the session and redirects the user to the base URL.

[source,python]
----
@app.route("/logout")
def logout():
    session.clear()
    return redirect("/")
----

Finally, add the base route, which uses Flask's template processor to render HTML that you will supply shortly.

[source,python]
----
@app.route("/")
def home():
    logout = env.get("ISSUER") + "/oauth2/logout?" + urlencode({"client_id": env.get("CLIENT_ID")},quote_via=quote_plus)

    return render_template(
        "home.html",
        session=session.get('user'), 
        profile=json.dumps(session.get('user'), indent=2),
        logoutUrl=logout)
----

Now, just add one more statement to run the app and listen on all available interfaces.

[source,python]
----
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=env.get("PORT", 3000))
----

With that, the server is finished.
Now create a new folder called `templates` and navigate into it

[source,shell]
----
mkdir templates && cd templates
----

Add a new file called `home.html` and insert the following into it.

[source,html]
----
<html>
<head>
  <meta charset="utf-8" />
  <title>FusionAuth OpenID and PKCE example</title>
</head>
<body>
  {% if session %}
      <h1>You are logged in as {{session.userinfo.email}}</h1>
      <h2>Here is your OpenID profile</h2>
      <div><pre>{{profile}}</pre></div>
      <br/>

      <p><a href="{{logoutUrl}}">Logout</a></p>
  {% else %}
    <h1>Hello Guest</h1>
    <p>Please <a href="/login">Login</a> to see your profile</p>
  {% endif %}
</body>
</html>
----

== Testing

Navigate back to the parent directory

[source,shell]
----
cd ..
----

and execute `flask run` to run your app.

[source,shell]
----
flask --app server.py run
----

This should return the following.

[source,txt]
----
 * Serving Flask app 'server.py'
 * Debug mode: off
WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
 * Running on http://127.0.0.1:5000
----

Open an incognito window and navigate to `http://127.0.0.1:5000`. 
Then hit `login`.

Enter in the email and password that you assigned to your FusionAuth user.  
If successful, you should see your OpenID profile information.

Now, hit `logout`. 
If successful, you should be brought right back to the `Hello Guest` homepage.
